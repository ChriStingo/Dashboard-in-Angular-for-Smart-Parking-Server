{"ast":null,"code":"import _asyncToGenerator from \"/home/chris/Documents/Dashboard/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"!raw-loader!./dashboard.component.html\";\nimport __NG_CLI_RESOURCE__1 from \"./dashboard.component.css\";\nimport { Component } from '@angular/core';\nlet DashboardComponent = class DashboardComponent {\n  // Contructor, called when whe dashboard is open\n  constructor() {\n    // Connection data\n    this.connection = false;\n    this.connectionStatus = 'Not connected';\n    this.reconnect = false;\n    this.server = \"127.0.0.1\";\n    this.port = \"8080\"; // Charts data\n\n    this.pieData = [];\n    this.lineData = [{\n      data: [0],\n      label: 'Waiting time (second)'\n    }]; // Parking data\n\n    this.Parks = [];\n    this.Brands = [];\n    this.animations = [];\n    this.parkingNumber = 'Undefined';\n    this.queueNumber = '0';\n    this.closed = false;\n  } // Close connection, changing Output data and showing pop-up\n\n\n  close() {\n    this.connectionStatus = 'Server Closed';\n    this.queueNumber = '0';\n    this.closed = true; // alert for user\n\n    this.reconnect = true; // display button\n  } // Send the http GET request to server on port, return response (data or STOP)\n\n\n  sendRequest(s) {\n    let response = '';\n\n    try {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', 'http://' + this.server + ':' + this.port + '/' + s, false); // sync request\n\n      xhr.onerror = function () {\n        close();\n      };\n\n      xhr.onreadystatechange = function () {\n        if (this.readyState == 4) {\n          if (this.status == 200) response = this.responseText;else {\n            close(); // server closed\n\n            response = \"STOP\";\n          }\n        }\n      };\n\n      xhr.send(null);\n      return response;\n    } catch (e) {\n      // server already closed, STOP is keyword sent by server if he is going to close, no difference for caller\n      return \"STOP\";\n    }\n  } // Prepare output to display, remove old elements, add new elements but not changing others\n\n\n  settingOutput(tmpParks, tmpBrands) {\n    // output arrays\n    let newParks = new Array(+this.parkingNumber);\n    let newBrands = new Array(+this.parkingNumber);\n    this.animations = []; // find unchanged park spot -> O(n + O(indexOf))\n\n    for (let i = 0; i < tmpParks.length; i++) {\n      let index = this.Parks.indexOf(tmpParks[i]); // index of new car inside old Parks\n\n      if (index != -1) {\n        // if was there\n        newParks[index] = tmpParks[i]; // leave it in the same spot\n\n        newBrands[index] = tmpBrands[i]; // every car -> its brand\n\n        tmpParks.splice(i, 1); // remove element from tmp array\n\n        tmpBrands.splice(i, 1);\n        i--;\n      }\n    } // insert new cars -> cost is inverse propotional of the overlying function, worst case O((n*(n+1))/2) = O(n*n)\n\n\n    for (let i = 0; i < tmpParks.length; i++) {\n      // for any other car\n      for (let j = i; j < +this.parkingNumber; j++) {\n        // find empty spot\n        if (typeof newParks[j] === \"undefined\") {\n          // add new car and brand\n          newParks[j] = tmpParks[i];\n          newBrands[j] = tmpBrands[i];\n          this.animations[j] = \"animation\"; // configure animation for this spot\n\n          break; // go to next car\n        }\n      }\n    } // output\n\n\n    this.Parks = newParks;\n    this.Brands = newBrands;\n  } // Polling to server retrieving data\n\n\n  retrieveData() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      do {\n        // Request to server to retrieve Parks, queueNumber and AvgQueueTime. Separate by ;\n        let response = _this.sendRequest('park').split(';');\n\n        if (response[0] == \"STOP\") {\n          // server stopped\n          _this.close();\n\n          continue;\n        } // update parking data\n\n\n        let tmpParks = Object.keys(JSON.parse(response[0].toUpperCase()));\n        let carsIn = tmpParks.length; // tmpParks will change with this.settingOutput() function\n\n        _this.queueNumber = response[1];\n\n        _this.settingOutput(tmpParks, Object.values(JSON.parse(response[0]))); // tmpParks and tmpBrands\n        // Charts data\n\n\n        _this.pieData = [carsIn, +_this.parkingNumber - carsIn];\n        if (((_a = _this.lineData[0].data) === null || _a === void 0 ? void 0 : _a.length) == 29) // if line chart is full, empty it\n          _this.lineData[0].data = [];\n        (_b = _this.lineData[0].data) === null || _b === void 0 ? void 0 : _b.push(+response[2] / 10); // polling delay\n\n        yield new Promise(f => setTimeout(f, 2000)); // time in millisec.\n      } while (!_this.closed); // while server is open\n\n    })();\n  } // Main function, called by Connect button\n\n\n  connect() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let infoData = _this2.sendRequest('info');\n\n      if (infoData != \"STOP\") {\n        // server is not closed\n        _this2.parkingNumber = infoData;\n        _this2.Parks = new Array(+_this2.parkingNumber);\n        _this2.connection = true;\n        _this2.reconnect = false;\n        _this2.closed = false;\n        _this2.connectionStatus = 'Connected';\n\n        _this2.retrieveData(); // start polling to retrieve data\n\n      } else _this2.close(); // server already closed\n\n    })();\n  }\n\n  ngOnInit() {}\n\n};\n\nDashboardComponent.ctorParameters = () => [];\n\nDashboardComponent = __decorate([Component({\n  selector: 'app-dashboard',\n  template: __NG_CLI_RESOURCE__0,\n  styles: [__NG_CLI_RESOURCE__1]\n})], DashboardComponent);\nexport { DashboardComponent };","map":{"version":3,"sources":["/home/chris/Documents/Dashboard/src/app/dashboard/dashboard.component.ts"],"names":[],"mappings":"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","sourcesContent":["import { Component, OnInit } from '@angular/core';\nimport { ChartDataSets } from 'chart.js';\nimport { SingleDataSet } from 'ng2-charts';\n\n// Used for AJAX\ndeclare var xhr: XMLHttpRequest;\n\n@Component({\n    selector: 'app-dashboard',\n    templateUrl: './dashboard.component.html',\n    styleUrls: ['./dashboard.component.css'],\n})\n\nexport class DashboardComponent implements OnInit {\n    // Connection data\n    connection: boolean;        // if there is/was at least one connection\n    connectionStatus: String;   // Output data\n    reconnect: boolean;         // if connecton ends\n    server: String;             // server address\n    port: String;               // server port\n\n    // Charts data\n    pieData: SingleDataSet;     // @Input in pie-data-component\n    lineData: ChartDataSets[];  // @Input in line-chart-component\n\n    // Parking data\n    Parks: string[];            // Output data, all the parking spot\n    Brands: string[];           // Output data, brands for parking spot\n    parkingNumber: String;      // Output data\n    queueNumber: String;        // Output data\n    closed: boolean;            // server status\n    animations: string[];       // Output data, for css\n\n    // Close connection, changing Output data and showing pop-up\n    private close() {\n        this.connectionStatus = 'Server Closed';\n        this.queueNumber = '0';\n        this.closed = true;     // alert for user\n        this.reconnect = true;  // display button\n    }\n\n    // Send the http GET request to server on port, return response (data or STOP)\n    private sendRequest(s: string) {\n        let response: string = '';\n        try {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', 'http://' + this.server + ':' + this.port + '/' + s, false); // sync request\n            xhr.onerror = function () {     // server closed\n                close();\n            };\n            xhr.onreadystatechange = function () {\n                if (this.readyState == 4) {\n                    if (this.status == 200) response = this.responseText;\n                    else {\n                        close();   // server closed\n                        response = \"STOP\";\n                    }\n                }\n            };\n            xhr.send(null);\n            return response;\n        } catch (e) {\n            // server already closed, STOP is keyword sent by server if he is going to close, no difference for caller\n            return \"STOP\";\n        }\n    }\n\n    // Prepare output to display, remove old elements, add new elements but not changing others\n    private settingOutput(tmpParks: string[], tmpBrands: string[]) {\n        // output arrays\n        let newParks = new Array(+this.parkingNumber);\n        let newBrands = new Array(+this.parkingNumber);\n        this.animations = [];\n\n        // find unchanged park spot -> O(n + O(indexOf))\n        for (let i = 0; i < tmpParks.length; i++) {\n            let index = this.Parks.indexOf(tmpParks[i]);    // index of new car inside old Parks\n            if (index != -1) {                              // if was there\n                newParks[index] = tmpParks[i];              // leave it in the same spot\n                newBrands[index] = tmpBrands[i];            // every car -> its brand\n                tmpParks.splice(i, 1);                      // remove element from tmp array\n                tmpBrands.splice(i, 1);\n                i--;\n            }\n        }\n\n        // insert new cars -> cost is inverse propotional of the overlying function, worst case O((n*(n+1))/2) = O(n*n)\n        for (let i = 0; i < tmpParks.length; i++) {             // for any other car\n            for (let j = i; j < +this.parkingNumber; j++) {     // find empty spot\n                if (typeof newParks[j] === \"undefined\") {       // add new car and brand\n                    newParks[j] = tmpParks[i];\n                    newBrands[j] = tmpBrands[i];\n                    this.animations[j] = \"animation\";           // configure animation for this spot\n                    break;                                      // go to next car\n                }\n            }\n        }\n\n        // output\n        this.Parks = newParks;\n        this.Brands = newBrands;\n    }\n\n    // Polling to server retrieving data\n    private async retrieveData() {\n        do {\n            // Request to server to retrieve Parks, queueNumber and AvgQueueTime. Separate by ;\n            let response = this.sendRequest('park').split(';');\n            if (response[0] == \"STOP\") {                    // server stopped\n                this.close();\n                continue;\n            }\n\n            // update parking data\n            let tmpParks: string[] = Object.keys(JSON.parse(response[0].toUpperCase()));\n            let carsIn = tmpParks.length;                   // tmpParks will change with this.settingOutput() function\n            this.queueNumber = response[1];\n            this.settingOutput(tmpParks, Object.values(JSON.parse(response[0])));   // tmpParks and tmpBrands\n\n\n            // Charts data\n            this.pieData = [\n                carsIn,\n                +this.parkingNumber - carsIn\n            ];\n            if (this.lineData[0].data?.length == 29)        // if line chart is full, empty it\n                this.lineData[0].data = [];\n            this.lineData[0].data?.push(+response[2] / 10);\n\n            // polling delay\n            await new Promise((f) => setTimeout(f, 2000));  // time in millisec.\n        } while (!this.closed);     // while server is open\n    }\n\n    // Main function, called by Connect button\n    async connect() {\n        let infoData = this.sendRequest('info');\n        if (infoData != \"STOP\") {    // server is not closed\n            this.parkingNumber = infoData;\n            this.Parks = new Array(+this.parkingNumber);\n            this.connection = true;\n            this.reconnect = false;\n            this.closed = false;\n            this.connectionStatus = 'Connected';\n            this.retrieveData();    // start polling to retrieve data\n        } else\n            this.close();           // server already closed\n    }\n\n    // Contructor, called when whe dashboard is open\n    constructor() {\n        // Connection data\n        this.connection = false;\n        this.connectionStatus = 'Not connected';\n        this.reconnect = false;\n        this.server = \"127.0.0.1\";\n        this.port = \"8080\";\n\n        // Charts data\n        this.pieData = [];\n        this.lineData = [{ data: [0], label: 'Waiting time (second)' }];\n\n        // Parking data\n        this.Parks = [];\n        this.Brands = [];\n        this.animations = [];\n        this.parkingNumber = 'Undefined';\n        this.queueNumber = '0';\n        this.closed = false;\n    }\n\n    ngOnInit() { }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}